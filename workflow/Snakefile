import os
import sys
import numpy as np
import pandas as pd

##################################################
# parse sample file
chroms = config["chromosomes"]
refvers = config["reference_version"]

sample_df = pd.read_table(config["sample_file"])

required = ["SAMPLE", "REP_ID", "DATA_TYPE", "PATH_to_bam"]
optional = ["PATH_to_barcodes", "PATH_to_10x_ranger"]

missing = [c for c in required if c not in sample_df.columns]
assert not missing, f"missing columns: {missing}"

for c in optional:
    if c not in sample_df.columns:
        sample_df[c] = pd.NA

SAMPLE_ID = sample_df["SAMPLE"].iloc[0]
assert (sample_df["SAMPLE"] == SAMPLE_ID).all(), "identical SAMPLE required"

sample_data_types = sample_df["DATA_TYPE"].unique().tolist()
allowed_data_types = ["bulkDNA", "scATAC", "scRNA", "VISIUM", "VISIUM3prime"]
assert all(dt in allowed_data_types for dt in sample_data_types)

if "bulkDNA" in sample_data_types:
    assert len(sample_data_types) == 1, "mode 1 must have only bulk samples. Run mode 1 with bulk-only samples to genotype then mode 2 on non-bulk samples."
    workflow_mode = "bulk"
else:
    workflow_mode = "single_cell"

rep_ids = sample_df["REP_ID"].unique().tolist()
get_data = {}
mod2reps = {}

bulk_nbams = []
bulk_tbams = []
gex_tbams = []
atac_tbams = []
for rep_id, rep_df in sample_df.groupby(by="REP_ID", sort=False):
    rep_data_types = rep_df["DATA_TYPE"].unique().tolist()
    barcodes = rep_df["PATH_to_barcodes"].iloc[0]
    rangers = rep_df["PATH_to_10x_ranger"].iloc[0]
    assert len(rep_data_types) <= 2, "at most 2 data types allowed per replicate"
    if len(rep_data_types) == 2:
        assert ("scRNA" in rep_data_types) and ("scATAC" in rep_data_types)
        assert len(rep_df) == 2, "multiome data should have exactly 2 rows"
        assert rep_df["PATH_to_barcodes"].nunique() == 1, f"multiome barcode paths differ"
        assert rep_df["PATH_to_10x_ranger"].nunique() == 1, f"multiome 10x-ranger paths differ"

        modality = "multiome"
        gex_bam = rep_df.loc[rep_df["DATA_TYPE"] == "scRNA", "PATH_to_bam"].iloc[0]
        atac_bam = rep_df.loc[rep_df["DATA_TYPE"] == "scATAC", "PATH_to_bam"].iloc[0]
        gex_tbams.append(gex_bam)
        atac_tbams.append(atac_bam)
        get_data[("scRNA", rep_id)] = [barcodes, gex_bam, rangers]
        get_data[("scATAC", rep_id)] = [barcodes, atac_bam, rangers]
    else:
        data_type = rep_data_types[0]
        modality = data_type
        bam = rep_df["PATH_to_bam"].iloc[0]
        get_data[(data_type, rep_id)] = [barcodes, bam, rangers]
        # bams = [bam]
        if data_type == "bulkDNA":
            assert rep_id == "normal" or rep_id[0] == "T", "bulk REP_ID must be either normal or starts with T"
            if rep_id == "normal":
                bulk_nbams.append(bam)
            else:
                bulk_tbams.append(bam)
        else:
            if data_type in ["scRNA", "VISIUM", "VISIUM3prime"]:
                gex_tbams.append(bam)
            else:
                atac_tbams.append(bam)
    if modality not in mod2reps:
        mod2reps[modality] = []
    mod2reps[modality].append(rep_id)

##################################################
# parse reference SNP file, if exists
ref_snp_file = config.get("ref_snp_file")
run_genotype_snps = ref_snp_file is None

##################################################
# parse genotype_snps and phase_snps inputs.
genotype_dtypes = []
has_normal = False
phaser = config.get("phaser", "undefined")
if run_genotype_snps:
    if workflow_mode == "bulk":
        genotype_dtypes = ["bulkDNA"]
        has_normal = len(bulk_nbams) > 0
    else:
        if len(gex_tbams) > 0:
            genotype_dtypes.append("scRNA")
        if len(atac_tbams) > 0:
            genotype_dtypes.append("scATAC")

    ##################################################
    # parse phase_snps inputs
    # define lambda functions that map chrname to genetic map file and phase panel file.
    if phaser == "eagle":
        assert config.get("eagle_dir") is not None
        gmap_dir = os.path.join(config["eagle_dir"], "tables")
        assert os.path.isdir(gmap_dir), "failed to locate gmap directory"
        assert refvers in ["hg17", "hg18", "hg19", "hg38"], "unsupported reference version"
        get_gmap_file = lambda chrname: os.path.join(gmap_dir, f"genetic_map_{refvers}_withX.txt.gz")

    elif phaser == "shapeit":
        assert config.get("shapeit_dir") is not None
        gmap_dir = os.path.join(config["shapeit_dir"], f"resources/maps")
        assert os.path.isdir(gmap_dir), "failed to locate gmap directory"
        assert refvers in ["hg19", "hg38"], "unsupported reference version"
        refvers2 = {"hg19": "b37", "hg38": "b38"}[refvers]
        get_gmap_file = lambda chrname: os.path.join(gmap_dir, f"{refvers2}/chr{chrname}.{refvers2}.gmap.gz")
    else:
        # TODO
        pass

    if phaser in ["eagle", "shapeit"]:
        assert all(os.path.exists(get_gmap_file(chrname)) for chrname in chroms), "failed to locate gmap files"
        phasing_panel_version = config["phasing_panel_version"]
        phasing_panel = config["phasing_panel"]
        assert os.path.isdir(phasing_panel), "failed to locate phasing panel"
        if phasing_panel_version == "1000G_hg38":
            get_phasing_panel = lambda chrname: os.path.join(phasing_panel, f"chr{chrname}.genotypes.bcf")
        else:
            raise ValueError(f"unsupported phasing_panel_version: {phasing_panel_version}")
        assert all(os.path.exists(get_phasing_panel(chrname)) for chrname in chroms), "failed to locate panel files"

##################################################
# final target files
final_targets = []

# optional genetic map file required by HATCHet3
# to estiamte population-based phases-switch errors.
if run_genotype_snps and phaser in ["eagle", "shapeit"]:
    final_targets.append("phase/genetic_map.tsv.gz")

for mod, rep_ids in mod2reps.items():
    data_types = ["scRNA", "scATAC"] if mod == "multiome" else [mod]
    if mod == "bulkDNA":
        # HATCHet input
        final_targets.append(f"allele/{mod}/sample_ids.tsv")
        final_targets.append(f"allele/{mod}/snp_info.tsv.gz")
        final_targets.append(f"allele/{mod}/snp_matrix.dp.npz")
        final_targets.append(f"allele/{mod}/snp_matrix.tot.npz")
        final_targets.append(f"allele/{mod}/snp_matrix.alt.npz")
        final_targets.append(f"allele/{mod}/snp_matrix.ref.npz")
        final_targets.append(f"allele/{mod}/snp_matrix.A.npz")
        final_targets.append(f"allele/{mod}/snp_matrix.B.npz")
    elif mod == "multiome":
        final_targets.extend([f"allele/{mod}_{rep_id}/sample_ids.tsv" for rep_id in rep_ids])
        final_targets.extend([f"allele/{mod}_{rep_id}/snp_info.tsv.gz" for rep_id in rep_ids])
        final_targets.extend([f"allele/{mod}_{rep_id}/barcodes.txt" for rep_id in rep_ids])
        for data_type in data_types:
            final_targets.extend([f"allele/{mod}_{rep_id}/{data_type}_snp_matrix.tot.npz" for rep_id in rep_ids])
            final_targets.extend([f"allele/{mod}_{rep_id}/{data_type}_snp_matrix.alt.npz" for rep_id in rep_ids])
            final_targets.extend([f"allele/{mod}_{rep_id}/{data_type}_snp_matrix.ref.npz" for rep_id in rep_ids])
            final_targets.extend([f"allele/{mod}_{rep_id}/{data_type}_snp_matrix.A.npz" for rep_id in rep_ids])
            final_targets.extend([f"allele/{mod}_{rep_id}/{data_type}_snp_matrix.B.npz" for rep_id in rep_ids])
    else:
        final_targets.append(f"allele/{mod}/sample_ids.tsv")
        final_targets.append(f"allele/{mod}/snp_info.tsv.gz")
        final_targets.append(f"allele/{mod}/barcodes.txt")
        final_targets.append(f"allele/{mod}/snp_matrix.tot.npz")
        final_targets.append(f"allele/{mod}/snp_matrix.alt.npz")
        final_targets.append(f"allele/{mod}/snp_matrix.ref.npz")
        final_targets.append(f"allele/{mod}/snp_matrix.A.npz")
        final_targets.append(f"allele/{mod}/snp_matrix.B.npz")
        # legacy CalicoST outputs
        final_targets.append(f"allele/{mod}/unique_snp_ids.npy")
        final_targets.append(f"allele/{mod}/cell_snp_Aallele.npz")
        final_targets.append(f"allele/{mod}/cell_snp_Ballele.npz")

##################################################
# entrypoint
include: "rules/genotype_snps.smk"
include: "rules/phase_snps.smk"
include: "rules/pileup_snps.smk"
include: "rules/postprocess.smk"
rule all:
    input: final_targets
    default_target: True
